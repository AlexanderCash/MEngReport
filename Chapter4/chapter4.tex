%******************************************************************************************************
%******************************* Fourth Chapter *******************************************************
%******************************************************************************************************

\externaldocument{{../Chapter1/chapter1}}
\externaldocument{{../Chapter2/chapter2}}
\externaldocument{{../Chapter3/chapter3}}
\externaldocument{{../Chapter5/chapter5}}

% **************************** Define Graphics Path **************************
\graphicspath{{Chapter4/Figs/}}


%******************************************************************************************************
%******************************************************************************************************
\chapter{Task Two: Path Following}
\label{task2}

This is the second of two tasks carried out in this project. Whilst our previous task was aimed at planning paths on the ground prior to flight, this task is aimed at commanding the UAV to fly such paths.


%******************************************************************************************************
%******************************************************************************************************
\section{Path Following - Aims}
\label{task2:aims}

The overarching aim for this task is to implement changes to ArduPlane to allow us to fly an air relative Dubins path as defined by the work already completed. Thanks to our path planning solution the UAV does not need to be aware of its ground relative location in order to successfully navigate to our desired point. The path following solution must simply interpret our description of a Dubins path and perform the desired manoeuvres. 

We need to be able to take a mission plan created using MissionPlanner or APM Planner 2 and insert a series of flight commands that will result in the UAV flying our desired Dubins path. To do this, we need to define the these commands in a format the autopulot will understand, and then enable the autopilot to respond to these input commands. 

We can summarise this tasks as being aimed at achieving the following:

\begin{itemize}
	\item Being able to describe a Dubins path using MAVLink messages %TODO introduce mavlink messages
	\item Enabling the UAV to interpret and act upon the new MAVLink messages
	\item Successfully command the UAV to fly a Dubins path, both with and without the presence of wind
	\item Successfully commanding the UAV to fly in wind to a ground relative point using a Dubins path 
\end{itemize}

From these aims, we can define a number of stages to split this task into, as we did with the previous task. Doing so simplifies design, implementation, and testing, whilst also providing clear milestones and cut off points to work well with the planning processes used in this project.These stages were defined as:

\begin{enumerate}
	\item Define the format of new commands required to fly a Dubins path
	\item Enable the UAV to interpret newly added commands
	\item Command the UAV to fly a Dubins path in both the presence and absence of wind
\end{enumerate}

%******************************************************************************************************
%******************************************************************************************************
\section{Path Following - Stage 1: Defining New Flight Commands}
\label{task2:stage1}

In this section we shall follow the design, implementation, and testing phases completed in order to define our new flight commands. This work prepares us for the next stage of adding functionality to ArduPlane so as to read, interpret, and act upon the new commands we have provided. 

\subsection{Stage 1: Design and Implementation}
\label{task2:stage1:design}

ArduPilot products use MAVLink messages to define all of the commands that may be included in a mission plan; a full list of the current MAVLink messages can be seen at \cite{MavlinkMessages}. A complete mission plan will simply be a collection of MAVLink messages, where each line corresponds to one MAVLink message, consisting of the following fields:

\begin{itemize}
	\item INDEX - an identifier for each command
	\item CURRENT WP - indicating which waypoint the command relates to (irrelevant for this project)
	\item COORD FRAME - indicates whether altitude values are relative to the takeoff altitude or to previous waypoint altitude
	\item COMMAND - the command number used to identify each instruction in the mission plan
	\item PARAM1 - optional parameter field
	\item PARAM2 - optional parameter field
	\item PARAM3 - optional parameter field
	\item PARAM4 - optional parameter field
	\item PARAM5/X/LONGITUDE - optional parameter field or a GPS longitude value 
	\item PARAM6/Y/LATITUDE - optional parameter field or a GPS latitude value
	\item PARAM7/Z/ALTITUDE - optional parameter field or an altitude value
	\item AUTOCONTINUE - flag to indicate whether to continue through the mission plan after this command
\end{itemize}

 To keep our system as simple as possible, it was decided that the easiest way to describe a Dubins path using MAVLink messages was to generate an individual message for each segment of the path. This would allow us to create a MAVLink message that indicated whether the segment needed to be a left-hand turn, right-hand turn, or a straight line. The console application created for path planning accepts the UAV's airspeed as an inpurt argument, and outputs the path as three segments and displays their length. This meant that it was very simple to create a MAVLink message indicating just two things; the segment turn direction, and the duration for the UAV to fly it. 

 As our paths had been designed independent of GPS co-ordinates, each MAVLink message only needed to include the command value, and the duration value in one of the parameter fields. We didn't need any GPS or altitude information in PARAM5, PARAM6, or PARAM7. By following the information found in the developer's wiki at \cite{ArduPilotMAVLink}, we were able to add four new commands. As we knew that our new commands were to be navigation commands, we followed the MAVLink convention of starting the names with ``MAV\_CMD\_NAV\_''. We decided to name our new messages as follows:

 \begin{enumerate}
 	\item MAV\_CMD\_NAV\_DUBIN\_LEFT
 	\item MAV\_CMD\_NAV\_DUBIN\_RIGHT
 	\item MAV\_CMD\_NAV\_DUBIN\_STRAIGHT
 	\item MAV\_CMD\_NAV\_DUMMY\_WP
 \end{enumerate}

 The last command was a dummy command, included so that we would be able to include one of these commands into a simulation, print out a message into the simulator console and therefore be confident that our commands were being read correctly by the autopilot. As the name would suggest, this final command was never intended to do anything other than provide a verification technique.

 The new message types were defined in \path{.../ardupilot/libraries/GCS\_MAVLINK/message\_definitions/ardupilotmega.xml}. This is the file where developers add platform specific commands, not intended to be shared with other ArduPilot products such as ArduCopter; this is because GCS\_MAVLINK is a shared library, in which most MAVLink messages are defined in the file \path{.../ardupilot/libraries/GCS\_MAVLINK/message\_definitions/common.xml}.

 An example of one of these definitions is as follows:

 \begin{minipage}{\linewidth}
\begin{lstlisting}[language=XML]
<entry name="MAV_CMD_NAV_DUBIN_RIGHT" value="86">
	<description>Perform a RIGHT turn segment of a dubins path turn</description>
	<param index="1">Duration of time to fly this segment</param>
	<param index="2">Empty</param>
	<param index="3">Empty</param>
	<param index="4">Empty</param>
	<param index="5">Empty</param>
	<param index="6">Empty</param>
	<param index="7">Empty</param>
</entry>
\end{lstlisting}
\end{minipage}

The numerical value chosen for each command is very important, as we have to ensure that all MAV\_CMD\_NAV entries are below 95, which is the value of the MAV\_CMD\_NAV\_LAST command, whilst also ensuring we are using values not currently in use. After double checking their values, the value 84 was assigned to the dummy command, 85 to the left hand turn command, 86 to a right hand turn command, and 87 to a straight segment. By running the \textit{generate.sh} script in the GCS\_MAVLINK directory we finalised this stage of the task, inserting our new commands into the header files used by ArduPlane to interpret MAVLink messages.

\subsection{Stage 1: Testing}
\label{task2:stage1:testing}

The changes produced by this stage were hard to truly test, however would be tested very thoroughly in later stages. The only real testing that was able to be performed at this stage was a visual inspection of the new header files produced. Browsing to \path{...ardupilot/libraries/GCS\_MAVLink/include/mavlink/v1.0/ardupilotmega/ardupilotmega.h} confirmed that all four of our new commands were present in the MAV\_CMD enum structure, along with the descriptions and correct command numbers entered in the XML file discussed above. 

%******************************************************************************************************
%******************************************************************************************************
\section{Path Following - Stage 2: Utilising New Flight Commands}
\label{task2:stage1}

In this section we discuss the design, implementation, and testing phase of enabling ArduPlane to read and interpret our newly defined mission commands. The implementation discussed here is the final and current version created as part of this project, however it was by no means the first method attempted. Further information regarding different approaches to solving this problem will be discussed in Chapter %TODO reference planning problems etc

\subsection{Stage 2: Design and Implementation}
\label{task2:stage2:design}

The design of our final implementation is in fact very simple. The first step towards completing this stage is to convert the MAVLink message into a \textit{cmd} structure, as described in \cite{ArduPilotMAVLink}. To do this we add a case for each of our new commands to the function \textit{mavlink\_to\_mission\_cmd} in \path{...ardupilot/libraries/AP\_Mission/AP\_Mission.cpp}. Each command issued to the autopilot via a MAVLink message is converted into an instance of a \textit{cmd} structure, which is itself composed of variables as well as a number of other data structures. To convert our message into one of these structures, we fill a data field in a \textit{Dubins\_Duration\_Command} structure, simply used to store the duration value for how long we wish to travel that given segment. This \textit{cmd} structure is then stored in memory, and will be accessed when it is time to complete the associated command. 

The next step is to instruct the autopilot to perform an action upon executing each of these commands. At the heart of ArduPlane is its scheduler, which it uses to periodically call a number of functions which include GPS updates, logging updates, and importantly, navigation updates. There are two scheduled functions we need to interact with; 

The first command that was implemented was the dummy commanded which we had created for testing purposes. 

\begin{figure}[htbp!] 
\centering    
\includegraphics[width=\textwidth]{Nav_flowdiagram}
\caption[]{}
\label{fig:navigateFlow}
\end{figure}


\subsection{Stage 2: Testing}
\label{task2:stage2:testing}


%******************************************************************************************************
%******************************************************************************************************
\section{Path Following - Stage 3: Flying Dubins Paths}
\label{task2:stage1}

\subsection{Stage 3: Design and Planning}
\label{task2:stage3:design}

\subsection{Stage 3: Implementation}
\label{task2:stage3:implementation}

\subsection{Stage 3: Testing}
\label{task2:stage3:testing}